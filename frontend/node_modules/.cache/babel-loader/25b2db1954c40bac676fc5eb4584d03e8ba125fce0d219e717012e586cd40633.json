{"ast":null,"code":"import _classCallCheck from \"C:/Users/paulm/Documents/Local Programming/Websites/SnowFinder/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/paulm/Documents/Local Programming/Websites/SnowFinder/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @internal\n */\nvar NULL = 0;\n/**\n * @internal\n */\nvar LF = 10;\n/**\n * @internal\n */\nvar CR = 13;\n/**\n * @internal\n */\nvar COLON = 58;\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(onFrame, onIncomingPing) {\n    _classCallCheck(this, Parser);\n    this.onFrame = onFrame;\n    this.onIncomingPing = onIncomingPing;\n    this._encoder = new TextEncoder();\n    this._decoder = new TextDecoder();\n    this._token = [];\n    this._initState();\n  }\n  _createClass(Parser, [{\n    key: \"parseChunk\",\n    value: function parseChunk(segment) {\n      var appendMissingNULLonIncoming = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var chunk;\n      if (typeof segment === 'string') {\n        chunk = this._encoder.encode(segment);\n      } else {\n        chunk = new Uint8Array(segment);\n      }\n      // See https://github.com/stomp-js/stompjs/issues/89\n      // Remove when underlying issue is fixed.\n      //\n      // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n      if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n        var chunkWithNull = new Uint8Array(chunk.length + 1);\n        chunkWithNull.set(chunk, 0);\n        chunkWithNull[chunk.length] = 0;\n        chunk = chunkWithNull;\n      }\n      // tslint:disable-next-line:prefer-for-of\n      for (var i = 0; i < chunk.length; i++) {\n        var byte = chunk[i];\n        this._onByte(byte);\n      }\n    }\n    // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n  }, {\n    key: \"_collectFrame\",\n    value: function _collectFrame(byte) {\n      if (byte === NULL) {\n        // Ignore\n        return;\n      }\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        // Incoming Ping\n        this.onIncomingPing();\n        return;\n      }\n      this._onByte = this._collectCommand;\n      this._reinjectByte(byte);\n    }\n  }, {\n    key: \"_collectCommand\",\n    value: function _collectCommand(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.command = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectHeaders\",\n    value: function _collectHeaders(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._setupCollectBody();\n        return;\n      }\n      this._onByte = this._collectHeaderKey;\n      this._reinjectByte(byte);\n    }\n  }, {\n    key: \"_reinjectByte\",\n    value: function _reinjectByte(byte) {\n      this._onByte(byte);\n    }\n  }, {\n    key: \"_collectHeaderKey\",\n    value: function _collectHeaderKey(byte) {\n      if (byte === COLON) {\n        this._headerKey = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaderValue;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectHeaderValue\",\n    value: function _collectHeaderValue(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n      if (byte === LF) {\n        this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n        this._headerKey = undefined;\n        this._onByte = this._collectHeaders;\n        return;\n      }\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_setupCollectBody\",\n    value: function _setupCollectBody() {\n      var contentLengthHeader = this._results.headers.filter(function (header) {\n        return header[0] === 'content-length';\n      })[0];\n      if (contentLengthHeader) {\n        this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n        this._onByte = this._collectBodyFixedSize;\n      } else {\n        this._onByte = this._collectBodyNullTerminated;\n      }\n    }\n  }, {\n    key: \"_collectBodyNullTerminated\",\n    value: function _collectBodyNullTerminated(byte) {\n      if (byte === NULL) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectBodyFixedSize\",\n    value: function _collectBodyFixedSize(byte) {\n      // It is post decrement, so that we discard the trailing NULL octet\n      if (this._bodyBytesRemaining-- === 0) {\n        this._retrievedBody();\n        return;\n      }\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_retrievedBody\",\n    value: function _retrievedBody() {\n      this._results.binaryBody = this._consumeTokenAsRaw();\n      try {\n        this.onFrame(this._results);\n      } catch (e) {\n        console.log(\"Ignoring an exception thrown by a frame handler. Original exception: \", e);\n      }\n      this._initState();\n    }\n    // Rec Descent Parser helpers\n  }, {\n    key: \"_consumeByte\",\n    value: function _consumeByte(byte) {\n      this._token.push(byte);\n    }\n  }, {\n    key: \"_consumeTokenAsUTF8\",\n    value: function _consumeTokenAsUTF8() {\n      return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n  }, {\n    key: \"_consumeTokenAsRaw\",\n    value: function _consumeTokenAsRaw() {\n      var rawResult = new Uint8Array(this._token);\n      this._token = [];\n      return rawResult;\n    }\n  }, {\n    key: \"_initState\",\n    value: function _initState() {\n      this._results = {\n        command: undefined,\n        headers: [],\n        binaryBody: undefined\n      };\n      this._token = [];\n      this._headerKey = undefined;\n      this._onByte = this._collectFrame;\n    }\n  }]);\n  return Parser;\n}();","map":{"version":3,"names":["NULL","LF","CR","COLON","Parser","onFrame","onIncomingPing","_classCallCheck","_encoder","TextEncoder","_decoder","TextDecoder","_token","_initState","_createClass","key","value","parseChunk","segment","appendMissingNULLonIncoming","arguments","length","undefined","chunk","encode","Uint8Array","chunkWithNull","set","i","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","command","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_setupCollectBody","_collectHeaderKey","_headerKey","_collectHeaderValue","headers","push","contentLengthHeader","filter","header","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","binaryBody","_consumeTokenAsRaw","e","console","log","decode","rawResult"],"sources":["C:\\Users\\paulm\\Documents\\Local Programming\\Websites\\SnowFinder\\frontend\\node_modules\\@stomp\\stompjs\\src\\parser.ts"],"sourcesContent":["import { IRawFrameType } from './types.js';\n\n/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n  private readonly _encoder = new TextEncoder();\n  private readonly _decoder = new TextDecoder();\n\n  // @ts-ignore - it always has a value\n  private _results: IRawFrameType;\n\n  private _token: number[] = [];\n  private _headerKey: string | undefined;\n  private _bodyBytesRemaining: number | undefined;\n\n  // @ts-ignore - it always has a value\n  private _onByte: (byte: number) => void;\n\n  public constructor(\n    public onFrame: (rawFrame: IRawFrameType) => void,\n    public onIncomingPing: () => void\n  ) {\n    this._initState();\n  }\n\n  public parseChunk(\n    segment: string | ArrayBuffer,\n    appendMissingNULLonIncoming: boolean = false\n  ) {\n    let chunk: Uint8Array;\n\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    }\n\n    // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n\n  private _collectFrame(byte: number): void {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n\n  private _collectCommand(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaders(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n\n  private _reinjectByte(byte: number) {\n    this._onByte(byte);\n  }\n\n  private _collectHeaderKey(byte: number): void {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectHeaderValue(byte: number): void {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([\n        this._headerKey as string,\n        this._consumeTokenAsUTF8(),\n      ]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(\n      (header: [string, string]) => {\n        return header[0] === 'content-length';\n      }\n    )[0];\n\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n\n  private _collectBodyNullTerminated(byte: number): void {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _collectBodyFixedSize(byte: number): void {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if ((this._bodyBytesRemaining as number)-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n\n  private _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(\n        `Ignoring an exception thrown by a frame handler. Original exception: `,\n        e\n      );\n    }\n\n    this._initState();\n  }\n\n  // Rec Descent Parser helpers\n\n  private _consumeByte(byte: number) {\n    this._token.push(byte);\n  }\n\n  private _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n\n  private _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n\n  private _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined,\n    };\n\n    this._token = [];\n    this._headerKey = undefined;\n\n    this._onByte = this._collectFrame;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}